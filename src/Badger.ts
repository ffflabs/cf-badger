
import { EnvWithDurableObject, json, error } from 'itty-router-extras';
import {
  GithubIntegrationDurable, mapRepos, dataItemToInstallationInfo,
  computeLoginHash
} from './GithubIntegrationDurable';
import type {
  TInstallationItem, TInstallationInfo

} from './GithubIntegrationDurable'
import type { IWorkflowRun, IWorkflowRuns, WorkflowRunPart, TRunResults } from './modules/computeColorAndMessage';
import { computeColorAndMessage, getLatestRunByBranch } from './modules/computeColorAndMessage';
import { GithubRequest, TWorkflowParams } from "./modules/GithubRequest";
import type { IInstallWebhook } from './modules/webhook_schemes';
import type { Octokit } from '@octokit/rest';
import { createKeyPair, decryptMessage, encryptMessage, getJWT } from './modules/signing_utils';

export const str2ab = (str) => {
  const buf = new ArrayBuffer(str.length);
  const bufView = new Uint8Array(buf);
  for (let i = 0, strLen = str.length; i < strLen; i++) {
    bufView[i] = str.charCodeAt(i);
  }
  return buf;
};


type TInstallations = {
  expiration: number;
  installations: {
    id: number;
    target_type: string;
    login: string | undefined;
  }[];
};

export interface IRequestParams {
  env: EnvWithDurableObject,
  owner: string,
  repo: string,
  workflow_id: number,

  requestURL: URL,
  hashHex: string,
  branch?: string
  verb?: string
  endpoint?: string,
  payload: IInstallWebhook
  code?: string
}



export type TOutputResults = ReturnType<typeof computeColorAndMessage> | {
  branches: TRunResults[];
  hashHex: string;
  count: number;
};

export type TInstallationRepos = {
  installationId: number | null;
  login: string;
  target_id?: number;
  expiration?: number;
  repositories: {
    id: number;
    name: string;
    full_name: string;
    private: boolean;
  }[];
};


// Generated by https://quicktype.io


export interface Permissions {
  actions: string;
  metadata: string;
}



type TOwnerRepo = {
  owner: string;
  repo: string;
};

type TOwnerOrInstallationId = {
  owner: string;
  installationId?: number;
} | {
  owner?: string;
  installationId: number;
};
// Generated by https://quicktype.io

export interface TWorkflow {
  id: number;
  node_id?: string;
  name: string;
  path?: string;
  state: string;
  created_at?: string;
  updated_at?: string;
  url?: string;
  html_url?: string;
  badge_url?: string;
  id_url?: string;
  filename_url?: string;
  runs?: string;
}
function mapWorkflow({ owner, repo, workflow }: { owner: string, repo: string, workflow: TWorkflow }, WORKER_URL: string): TWorkflow {
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  let { id, name, state, url, path, node_id } = workflow, fileName = String(path).split('/').pop();
  return {
    id,
    name,
    state,
    url,//: `${requestURL.toString()}/${id}`,
    filename_url: `https://github.com/${owner}/${repo}/actions/workflows/${fileName}`,
    runs: `${WORKER_URL}/badger/${owner}/${repo}/${id}`,
    node_id
    //  html_url
  };


}

interface IRepoWorkflows {
  total_count: number,
  workflows: TWorkflow[]
}
type ErrorResponse = {
  response: {
    status: number,
    url: string,
    data: { [s: string]: unknown }
  }
}
function isErrorResponse(err: unknown, status?: number): err is ErrorResponse {
  let maybeErrorResponse = err as ErrorResponse
  return !!maybeErrorResponse.response
    && typeof maybeErrorResponse.response.url === 'string'
    && typeof maybeErrorResponse.response.status === 'number'
    && (!status || maybeErrorResponse.response.status === status)
}
export class Badger extends GithubIntegrationDurable implements DurableObject {
  [s: string]: unknown

  async getInstallation({ owner, installationId }: TOwnerOrInstallationId): Promise<TInstallationInfo> {
    if (/^\d+$/.test(owner || '')) installationId = Number(owner)
    return (installationId ? this.getInstallById({ installationId }) : this.getOwnerInstall({ owner } as { owner: string }))
  }

  async getRepositories({ owner, installationId, code }: TOwnerOrInstallationId & { code?: string }): Promise<TInstallationRepos> {
    let cacheKey = `repositories:${String(owner || installationId)}`
    let stored = await this.getStoredWithTtl<TInstallationRepos>(cacheKey)

    if (stored.ttl) return stored
    if (/^\d+$/.test(owner || '')) installationId = Number(owner)
    try {
      let installationInfo = await this.getInstallation({ owner, installationId } as TOwnerOrInstallationId)
      installationId = Number(installationInfo.installationId || installationInfo.id)

      return (await this.getOctokitForInstallation(installationId)).apps.listReposAccessibleToInstallation({ installation_id: installationId })
        .then(({ data: { repositories } }): TInstallationRepos => {
          let { login, target_id } = installationInfo,
            finalResult = { installationId, login, target_id, repositories: mapRepos(repositories, this.state.WORKER_URL) } as unknown as TInstallationRepos;


          return this.storeWithExpiration(cacheKey, finalResult)
        });
    } catch (err) {
      /**
       * Plan B, attempt using logged in user token
       */
      if (isErrorResponse(err, 404) && owner && code) {
        return this.getReposForUser({ code, owner })


      }
      throw err
    }
  }
  async getReposForUser({ code, owner }: { code: string, owner: string }): Promise<TInstallationRepos> {
    return this.actingAsUser(code).then(userOctokit => {
      return userOctokit.repos.listForUser({ username: owner }).then(({ data }): TInstallationRepos & { install_url: string } => {
        let firstOrg = data[0]
        if (!firstOrg) {
          throw new Error('Could not get related repos for user')
        }
        let user = firstOrg.owner,
          { id: target_id } = user
        return {
          installationId: null,
          login: user.login,
          target_id,

          install_url: `https://github.com/apps/cf-badger/installations/new/permissions?target_id=${target_id}`,
          repositories: mapRepos(data, this.state.WORKER_URL)
        }

      })
    })
  }
  async getRepoWorkflows({ owner, repo, code }: TOwnerRepo & { code?: string } = {} as TOwnerRepo): Promise<{ workflows: TWorkflow[] }> {
    let cacheKey = `workflows:${owner}/${repo}`
    let stored = await this.getStoredWithTtl<{ workflows: TWorkflow[] }>(cacheKey)
    if (stored.ttl) return stored
    return Promise.resolve().then(async () => {
      let installationInfo = await this.getOwnerInstall({ owner } as { owner: string }),
        installationId = Number(installationInfo.installationId || installationInfo.id)
      return this.getOctokitForInstallation(installationId)
    }).catch(err => {
      if (isErrorResponse(err, 404) && owner && code) {
        return this.actingAsUser(code)
      }
      throw err
    }).then((octokit) => {
      return octokit.actions.listRepoWorkflows({ owner, repo }).then(({ data }) => {
        let { workflows } = data as IRepoWorkflows
        return this.storeWithExpiration(cacheKey, { workflows: workflows.map(workflow => mapWorkflow({ owner, repo, workflow }, this.state.WORKER_URL)) })
      })
    })

  }
  async getWorkflowResults({ owner, repo, workflow_id, code }: TOwnerRepo & { code?: string, workflow_id: number }): Promise<TOutputResults> {
    return Promise.resolve().then(async () => {
      let installationInfo = await this.getOwnerInstall({ owner } as { owner: string }),
        installationId = Number(installationInfo.installationId || installationInfo.id)
      return this.getOctokitForInstallation(installationId)
    }).catch(err => {
      if (isErrorResponse(err, 404) && owner && code) {
        return this.actingAsUser(code)
      }
      throw err
    }).then((octokit) => {
      return octokit.actions.listWorkflowRuns({ owner, repo, workflow_id }).then(({ data }) => {
        let { workflow_runs, total_count } = data,
          runs = getLatestRunByBranch(workflow_runs as WorkflowRunPart[]) as { [s: string]: TRunResults }
        return { branches: Object.values(runs), hashHex: '', count: total_count }
      })
    })
  }


  /**
   * This operation retrieves at most 100 run results for a given workflow. 
   * Given the potential size of the response we store it on a KVNamespace instead
   * of bloating the Durable Object's storage
   * @param param0 
   * @returns 
   */
  async computeResultRequest({
    owner,
    repo,
    workflow_id,
    GITHUB_TOKEN,

    hashHex,
    branch
  }: {
    owner: string,
    repo: string,
    workflow_id: string,
    GITHUB_TOKEN: string,

    hashHex: string,
    branch?: string
  }): Promise<TOutputResults> {
    this.state.storage.put<TWorkflowParams & { GITHUB_TOKEN: string }>(`hash:${hashHex}`,
      {
        owner, repo, workflow_id, GITHUB_TOKEN
      })
    let { value: storedRuns, metadata } = await this.state.BADGER_KV.getWithMetadata<IWorkflowRuns>(`runs:${hashHex}`, 'json')
    console.log({
      owner, repo, workflow_id, metadata
    })
    if (!storedRuns) {
      const ghRequest = new GithubRequest({ owner, repo, workflow_id, branch }, GITHUB_TOKEN)

      const res = await ghRequest.fetch({ method: 'GET' }),
        body = res.clone().body
      if (body) {
        this.state.waitUntil(this.state.BADGER_KV.put(`runs:${hashHex}`, body, { expirationTtl: 300, metadata: { CachedOn: Date.now() } }))
      }
      storedRuns = (await res.json()) as IWorkflowRuns
    }
    let { workflow_runs } = storedRuns,
      runs = workflow_runs.map(run => {
        let { id, name, head_branch, status, conclusion, workflow_id: wf_id } = run;
        return { id, name, head_branch, status, conclusion, workflow_id: wf_id }
      });

    runs = Object.values(runs.reduce((accum, run) => {
      let { head_branch } = run
      accum[head_branch] = accum[head_branch] || run;
      return accum;
    }, {} as { [s: string]: WorkflowRunPart; }));


    return { branches: runs, hashHex, count: workflow_runs.length }
  }
  async computeResultRequestFromHash({ hashHex, branch }: { hashHex: string, branch?: string }): Promise<Response> {

    const { owner, repo, workflow_id, GITHUB_TOKEN } = (await this.state.storage.get(`hash:${hashHex}`) || {}) as TWorkflowParams & { GITHUB_TOKEN: string }

    const ghRequest = new GithubRequest({ owner, repo, workflow_id, branch }, GITHUB_TOKEN),
      res = await ghRequest.fetch({ method: 'GET' });


    const { workflow_runs } = (await res.json()) as IWorkflowRuns, runs = workflow_runs.map((run) => {
      let { id, name, head_branch, status, conclusion, workflow_id: wf_id } = run;
      return { id, name, head_branch, status, conclusion, workflow_id: wf_id };
    })

    return json(computeColorAndMessage(runs as IWorkflowRun[], Number(workflow_id), branch), {
      headers: {
        'cache-control': 'max-age=300, public'
      }
    })
  }

  // Generated by https://quicktype.io
  async user({ code, installationId }: { code: string, installationId?: number }): Promise<Response> {

    let props = (await this.state.storage.get(code) || { token: '', login: '' }) as { [s: string]: unknown }
    if (!props.token) {
      return this.actingAsOauthUser(code)
    }

    return this.actingAsUser(code).then(userOctoKit => {



      userOctoKit.code = code
      let reposForInstallation = Promise.resolve({} as TInstallationRepos | { installations: TInstallationInfo[] })

      return this.getUserPublicRepos(userOctoKit).then(async (viewer) => {
        const { login: username, databaseId, repo_count } = viewer
        console.log({ code, installationId, username })

        if (installationId) {
          reposForInstallation = this.getRepositories({ installationId })
        }
        const installations = await this.getInstallationsForUser(userOctoKit as Octokit & { code: string }, installationId)

        let payload = {
          login: username, id: Number(databaseId), installations: installations.reduce((accum, i) => {
            accum[i.login] = i.installationId
            return accum
          }, {} as { [s: string]: number })
        }

        /*   const privateKey = await this.getPrivateCryptoKey({
             name: 'RSASSA-PKCS1-v1_5',
             hash: { name: 'SHA-256' },
           }),
             jwt = await getJWT({ privateKey, payload }),
          
             */
        //const publicKey: CryptoKey = await this.getPublicCryptoKey()
        //
        //
        //encryptedHash = await encryptMessage(hashParams, publicKey)
        return reposForInstallation.then(installation_repos => {
          return json({ ...installation_repos, ...payload, repo_count, installations, public_repos: viewer.repositories })
        });
      }).catch(err => {

        return this.errorToResponse(err, { gh_code: code })
      })
    })
  }


  /**
   * 
   * @param owner 
   * @returns 
   */
  private async getOwnerInstall({ owner }: { owner: string }): Promise<TInstallationInfo> {

    let stored = await this.getStoredWithTtl<TInstallationInfo>(`owner:${owner}`)
    if (stored.ttl) return stored

    return this.getOctokit().apps.getUserInstallation({ username: owner })
      .then(async ({ data }) => {
        console.log('got owner installation')
        const installationInfo = dataItemToInstallationInfo(data as unknown as TInstallationItem, this.state.WORKER_URL)
        installationInfo.installationId = installationInfo.installationId || installationInfo.id
        this.storeWithExpiration(`owner:${owner}`, installationInfo, 1000000)
        this.storeWithExpiration(`installationId:${installationInfo.installationId}`, installationInfo, 1000000)
        return installationInfo

      })
  }
  /**
   * 
   * @param owner 
   * @returns 
   */
  private async getInstallById({ installationId }: { installationId: number }): Promise<TInstallationInfo> {

    let stored = await this.getStoredWithTtl<TInstallationInfo>(`installationId:${installationId}`)
    if (stored.ttl) return stored

    return (await this.getOctokitForInstallation(installationId)).apps.getInstallation({ installation_id: installationId }).then(async ({ data }) => {

      const installationInfo = dataItemToInstallationInfo(data as unknown as TInstallationItem, this.state.WORKER_URL)
      installationInfo.installationId = installationInfo.installationId || installationInfo.id

      this.storeWithExpiration(`installationId:${installationId}`, installationInfo, 1000000)
      this.storeWithExpiration(`owner:${installationInfo.login}`, installationInfo, 1000000)
      return installationInfo

    })
  }
  async listInstallations(): Promise<TInstallations> {

    let stored = await this.getStoredWithTtl<TInstallations>(`listInstallations`)
    if (stored.ttl) return stored
    const { data } = await this.getOctokit().apps.listInstallations()
    const installations = (data as TInstallationItem[]).map(i => dataItemToInstallationInfo(i, this.state.WORKER_URL))

    return this.storeWithExpiration(`listInstallations`, { installations })
  }


}
