
//import { version } from '../package.json';
import { fallbackSvg } from './modules/fallback_svg';
import { Router } from 'itty-router'
import { playgroundHTML } from './frontend'
interface IWaitableObject {
  waitUntil: (promise: Promise<any>) => void;
}
// Generated by https://quicktype.io



// Generated by https://quicktype.io



interface IPkgConfig {
  name: string;
  description: string;
  main: string;
  version: string;
}


import Toucan from 'toucan-js';
import type { Context } from 'toucan-js/dist/types';
import { Status, Conclusion, IWorkflowList, IWorkflowRuns, computeColorAndMessage, WorkflowRun } from './handler';

const pkg: IPkgConfig = require('../package.json'),
  { version: release } = pkg


interface EnvWithBindings {
  GITHUB_TOKEN: boolean;
  USE_AVIF: boolean;
  WORKER_NAMESPACE: string;
  PNG_QUALITY: number;
  JPG_QUALITY: number;
  SENTRY_CONNSTRING: string;
  WORKER_ENV: string;
  USE_CACHE: boolean;
}
function getSentryInstance(ctx: Context, env: EnvWithBindings): Toucan {
  return new Toucan({
    context: ctx,
    request: ctx.request,
    dsn: String(env.SENTRY_CONNSTRING),
    environment: String(env.WORKER_ENV),
    release,
    debug: false,
    pkg,
  });
}
export type TctxWithSentry = {
  request: Request;
  sentry: Toucan;
} & IWaitableObject;

function computeGithubRequest({ repo, owner, workflow_id }: { repo: string, owner: string, workflow_id?: string }, env: EnvWithBindings): Request {
  const cfInit = {
    headers: {
      Accept: "application/vnd.github.v3+json",
      Authorization: `token ${env.GITHUB_TOKEN}`
    }
  },
    ghRequest = new Request(`https://api.github.com/repos/${owner}/${repo}/actions/workflows${workflow_id ? ('/' + workflow_id + '/runs') : ''}`, cfInit);
  console.log({ ghRequestUrl: ghRequest.url.toString(), cfInit })
  return ghRequest
}
function computeErroredResponse({ owner, repo }: { owner: string, repo: string }, res: Response): Error {
  return new Error(`Request to ${owner}/${repo} failed with status: ${res.status} ${res.statusText}`)
}
const router = Router()

type RequestWithParams = Request & {
  params: {
    [s: string]: string;
  };
};

router.get('/:owner/:repo', async (request: RequestWithParams, env: EnvWithBindings, ctx: TctxWithSentry): Promise<Response> => {
  let { url, params: { owner, repo } } = request,
    ghRequest = computeGithubRequest({ owner, repo }, env)

  ctx.sentry.addBreadcrumb({ data: { url, ghRequest } });

  const res = await fetch(ghRequest)
  if (!res.ok) {
    throw computeErroredResponse({ owner, repo }, res)
  }
  const { workflows } = (await res.json()) as IWorkflowList,
    workflow_runs_urls = workflows.map(workflow => {
      let { id, name, path } = workflow, fileName = path.split('/').pop()
      return { id_url: `${url}/${id}`, name, filename_url: `${url}/${fileName}` }
    })


  return new Response(JSON.stringify(workflow_runs_urls), { headers: { 'Content-Type': 'application/json; charset=utf-8' } })

})
  .get('/:owner/:repo/:workflow_id', async (request: RequestWithParams, env: EnvWithBindings, ctx: TctxWithSentry): Promise<Response> => {
    let { url, params: { owner, repo, workflow_id: wf_id } } = request,
      requestURL = new URL(url),
      branch = requestURL.searchParams.get('branch') || 'master',
      ghRequest = computeGithubRequest({ owner, repo, workflow_id: wf_id }, env)

    ctx.sentry.addBreadcrumb({ data: { url, ghRequest } });
    const res = await fetch(ghRequest)
    if (!res.ok) {
      throw computeErroredResponse({ owner, repo }, res)
    }
    const { workflow_runs } = (await res.json()) as IWorkflowRuns,
      runs = workflow_runs.map((run): Pick<WorkflowRun, 'id' | 'name' | 'head_branch' | 'status' | 'conclusion' | 'workflow_id'> => {
        let { id, name, head_branch, status, conclusion, workflow_id } = run
        return { id, name, head_branch, status, conclusion, workflow_id }
      })
    return new Response(JSON.stringify({ msg: computeColorAndMessage(runs as WorkflowRun[], branch, Number(wf_id)), runs }), { headers: { 'Content-Type': 'application/json; charset=utf-8' } })


  })
  .get('/favicon.ico', () => new Response(fallbackSvg, { headers: { 'Content-Type': 'image/svg' } }))
  .get('/', () => new Response(playgroundHTML, { headers: { 'Content-Type': 'text/html' } }))
const exportDefault = {
  fetch: async (request: Request, env: EnvWithBindings, ctx: TctxWithSentry): Promise<Response> => {
    return Promise.resolve(router.handle(request, env, ctx))
      .catch((err) => {
        let event_id = ctx.sentry.captureException(err),
          warnObj = {
            event_id,
            error: err.message,
            stack: err.stack.split('\n'),
          };

        console.warn(warnObj);
        return new Response(JSON.stringify(warnObj), {
          status: 200,
          headers: {
            'content-type': 'application/json',
          },
        });
      });
  }
}
addEventListener('fetch', async (event: FetchEvent) => {
  //console.log({ url, keys: Object.keys(event.request) })
  const env: EnvWithBindings = {
    GITHUB_TOKEN,
    USE_AVIF,
    WORKER_NAMESPACE,
    PNG_QUALITY,
    JPG_QUALITY,
    SENTRY_CONNSTRING,
    WORKER_ENV,
    USE_CACHE,
  },
    { request } = event,
    waitUntil = event.waitUntil.bind(event),
    ctx: TctxWithSentry = {
      waitUntil,
      sentry: getSentryInstance({ request, waitUntil }, env),
      request,
    }
  console.log({ env })
  event.respondWith(exportDefault.fetch(request, env, ctx))



});


